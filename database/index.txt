-- === EXTENSIONS ===
create extension if not exists "uuid-ossp";
create extension if not exists "pgcrypto";

-- === ENUMs ===
do $$
begin
  if not exists (select 1 from pg_type where typname = 'attendance_method') then
    create type attendance_method as enum ('face','barcode','manual');
  end if;
end$$;

-- === Bảng quyền người dùng ứng dụng (liên kết auth.users) ===
create table if not exists public.user_roles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  role text not null check (role in ('admin','viewer')),
  created_at timestamptz not null default now()
);

-- === Hàm tiện ích kiểm tra admin ===
create or replace function public.is_admin() returns boolean
language sql stable
as $$
  select exists (
    select 1 from public.user_roles ur
    where ur.user_id = auth.uid() and ur.role = 'admin'
  );
$$;

-- === Lớp học ===
create table if not exists public.classes (
  id uuid primary key default gen_random_uuid(),
  code text unique not null,              -- ví dụ: IT01
  name text not null,                     -- ví dụ: Công Nghệ Thông Tin 01
  created_at timestamptz default now()
);

-- === Hồ sơ người dùng (SV/NV) ===
create table if not exists public.profiles (
  id uuid primary key default gen_random_uuid(),
  code text unique not null,              -- mã thẻ/mã SV (dùng khi quét barcode)
  full_name text not null,
  class_id uuid references public.classes(id) on delete set null,
  is_active boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create or replace function public.touch_profiles_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now(); 
  return new;
end$$;

drop trigger if exists trg_profiles_updated on public.profiles;
create trigger trg_profiles_updated
before update on public.profiles
for each row execute function public.touch_profiles_updated_at();

-- === Embeddings khuôn mặt ===
-- Lưu nhiều vector để tăng độ bền (ánh sáng/góc mặt khác nhau)
create table if not exists public.face_embeddings (
  user_id uuid primary key references public.profiles(id) on delete cascade,
  vectors jsonb not null,                 -- ví dụ: [[0.12, -0.03, ...], [ ... ]]
  samples_count int generated always as ((jsonb_array_length(vectors))) stored,
  updated_at timestamptz not null default now()
);

create or replace function public.touch_embeddings_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end$$;

drop trigger if exists trg_face_embeddings_updated on public.face_embeddings;
create trigger trg_face_embeddings_updated
before update on public.face_embeddings
for each row execute function public.touch_embeddings_updated_at();

-- === Bảng điểm danh ===
create table if not exists public.attendance (
  id bigserial primary key,
  user_id uuid references public.profiles(id) on delete set null,
  method attendance_method not null,
  confidence_score float check (confidence_score >= 0 and confidence_score <= 1),
  at_time timestamptz not null default now(),
  note text
);

-- === Indexes khuyến nghị ===
create index if not exists idx_profiles_code on public.profiles(code);
create index if not exists idx_profiles_class on public.profiles(class_id);
create index if not exists idx_attendance_user_time on public.attendance(user_id, at_time desc);
create index if not exists idx_attendance_method on public.attendance(method);
create index if not exists idx_attendance_time_range on public.attendance using brin (at_time);

-- === STORED FUNCTIONS ===
-- Function thống kê attendance
create or replace function get_attendance_stats(
    from_date timestamptz default null,
    to_date timestamptz default null
)
returns table (
    method attendance_method,
    count bigint,
    percentage decimal
) 
language sql stable
as $$
    with filtered_attendance as (
        select a.method
        from attendance a
        where 
            (from_date is null or a.at_time >= from_date)
            and (to_date is null or a.at_time <= to_date)
    ),
    total_count as (
        select count(*) as total from filtered_attendance
    )
    select 
        fa.method,
        count(*) as count,
        round(count(*)::decimal / nullif(tc.total, 0) * 100, 2) as percentage
    from filtered_attendance fa
    cross join total_count tc
    group by fa.method, tc.total;
$$;

-- Function tìm kiếm user bằng face embeddings
create or replace function find_matching_face(
    target_embedding jsonb,
    similarity_threshold float default 0.8
)
returns table (
    user_id uuid,
    full_name text,
    similarity_score float
)
language plpgsql stable
as $$
declare
    embedding_vector float[];
    stored_vectors jsonb;
    stored_vector float[];
    max_similarity float;
    current_similarity float;
begin
    -- Convert input embedding to array
    select array(select jsonb_array_elements_text(target_embedding)::float) into embedding_vector;
    
    -- Loop through all face embeddings
    for user_id, full_name, stored_vectors in
        select fe.user_id, p.full_name, fe.vectors
        from face_embeddings fe
        join profiles p on fe.user_id = p.id
        where p.is_active = true
    loop
        max_similarity := 0;
        
        -- Check similarity with each stored vector for this user
        for i in 0..jsonb_array_length(stored_vectors)-1 loop
            select array(select jsonb_array_elements_text(stored_vectors->i)::float) into stored_vector;
            
            -- Calculate cosine similarity
            current_similarity := (
                select sum(embedding_vector[i] * stored_vector[i])
                from generate_subscripts(embedding_vector, 1) as i
            ) / (
                sqrt(sum(power(embedding_vector[i], 2))) * 
                sqrt(sum(power(stored_vector[i], 2)))
            );
            
            if current_similarity > max_similarity then
                max_similarity := current_similarity;
            end if;
        end loop;
        
        -- Return if similarity is above threshold
        if max_similarity >= similarity_threshold then
            similarity_score := max_similarity;
            return next;
        end if;
    end loop;
    
    return;
end;
$$;

-- =========================================
-- RLS (Row-Level Security)
-- =========================================
alter table public.user_roles enable row level security;
alter table public.classes enable row level security;
alter table public.profiles enable row level security;
alter table public.face_embeddings enable row level security;
alter table public.attendance enable row level security;

-- user_roles policies
drop policy if exists ur_select on public.user_roles;
drop policy if exists ur_admin_all on public.user_roles;

create policy ur_select on public.user_roles
for select to authenticated
using (true);

create policy ur_admin_all on public.user_roles
for all to authenticated
using (public.is_admin())
with check (public.is_admin());

-- classes policies
drop policy if exists classes_select on public.classes;
drop policy if exists classes_admin_all on public.classes;

create policy classes_select on public.classes
for select to authenticated
using (true);

create policy classes_admin_all on public.classes
for all to authenticated
using (public.is_admin())
with check (public.is_admin());

-- profiles policies
drop policy if exists profiles_select on public.profiles;
drop policy if exists profiles_admin_all on public.profiles;

create policy profiles_select on public.profiles
for select to authenticated
using (true);

create policy profiles_admin_all on public.profiles
for all to authenticated
using (public.is_admin())
with check (public.is_admin());

-- face_embeddings policies
drop policy if exists fe_select on public.face_embeddings;
drop policy if exists fe_admin_all on public.face_embeddings;

create policy fe_select on public.face_embeddings
for select to authenticated
using (true);

create policy fe_admin_all on public.face_embeddings
for all to authenticated
using (public.is_admin())
with check (public.is_admin());

-- attendance policies
drop policy if exists atd_select on public.attendance;
drop policy if exists atd_admin_insert on public.attendance;
drop policy if exists atd_admin_update on public.attendance;
drop policy if exists atd_admin_delete on public.attendance;

create policy atd_select on public.attendance
for select to authenticated
using (true);

create policy atd_admin_insert on public.attendance
for insert to authenticated
with check (public.is_admin());

create policy atd_admin_update on public.attendance
for update to authenticated
using (public.is_admin())
with check (public.is_admin());

create policy atd_admin_delete on public.attendance
for delete to authenticated
using (public.is_admin());

create table if not exists public.faculties (
  id uuid primary key default gen_random_uuid(),
  code text unique not null,    -- mã khoa, ví dụ CNTT
  name text not null,           -- tên khoa, ví dụ Công nghệ thông tin
  created_at timestamptz not null default now()
);
alter table public.classes
add column if not exists faculty_id uuid references public.faculties(id) on delete set null;

alter table public.faculties enable row level security;

-- Drop old policies if exist (for update and select)
drop policy if exists faculties_select on public.faculties;
drop policy if exists faculties_admin_all on public.faculties;

-- Policy: Anyone authenticated can SELECT
create policy faculties_select on public.faculties
for select to authenticated
using (true);

-- Policy: Only admin can INSERT/UPDATE/DELETE
create policy faculties_admin_all on public.faculties
for all to authenticated
using (public.is_admin())
with check (public.is_admin());

-- Recommended indexes for faculties table
create index if not exists idx_faculties_code on public.faculties(code);
create index if not exists idx_faculties_name on public.faculties(name);